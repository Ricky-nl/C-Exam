<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Programming MCQ Exam</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            text-align: center;
        }
        .question {
            margin-bottom: 20px;
        }
        .question h3 {
            margin-bottom: 10px;
        }
        .options {
            list-style-type: none;
            padding: 0;
        }
        .options li {
            margin-bottom: 5px;
        }
        #result {
            margin-top: 20px;
            font-weight: bold;
        }
        .feedback {
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>C Programming MCQ Exam</h1>
    <form id="examForm">
        <!-- Questions dynamically added here -->
        <button type="button" onclick="gradeExam()">Submit</button>
    </form>

    <div id="result"></div>

    <script>
        // Array of questions (60 total)
        <script>
const questions = [
    // Pointers Section (Advanced)
    { question: "What will the following code output?\n\n```c\nint x = 5, *p = &x, **q = &p;\n**q = 10;\nprintf('%d', x);\n```", options: ["10", "5", "Segmentation fault", "Error"], correct: 0 },
    { question: "What happens when you try to dereference a pointer that was initialized to an invalid memory address?", options: ["Segmentation fault", "The program continues without issues", "The pointer is set to NULL", "None of the above"], correct: 0 },
    { question: "What will be the output of the following code?\n\n```c\nint *ptr = NULL;\nif (ptr) {\n    printf('True');\n} else {\n    printf('False');\n}\n```", options: ["True", "False", "Error", "Segmentation fault"], correct: 1 },
    
    // Structures Section (Advanced)
    { question: "Given the following structure:\n\n```c\nstruct Person {\n    char name[100];\n    int age;\n    struct Address *address;\n};\nstruct Address {\n    char street[100];\n    char city[100];\n};\n``` What is the proper way to dynamically allocate memory for both the 'Person' and 'Address' structures?", options: ["struct Person *p = malloc(sizeof(struct Person)); p->address = malloc(sizeof(struct Address));", "struct Person *p = malloc(sizeof(struct Person));", "struct Address *a = malloc(sizeof(struct Address));", "None of the above"], correct: 0 },
    { question: "Which of the following statements is correct about the 'sizeof' operator in C?", options: ["It gives the size of a variable or data type", "It cannot be used with structures", "It only works with pointers", "None of the above"], correct: 0 },
    
    // Dynamic Memory Section (Advanced)
    { question: "Which function should be used to change the size of previously allocated memory?", options: ["malloc()", "free()", "realloc()", "calloc()"], correct: 2 },
    { question: "What happens when 'malloc' is called but the system runs out of memory?", options: ["It returns NULL", "It throws an error", "It returns a random address", "None of the above"], correct: 0 },
    { question: "What will be the result of this code?\n\n```c\nint *arr = malloc(5 * sizeof(int));\nfor (int i = 0; i < 5; i++) {\n    arr[i] = i + 1;\n}\narr = realloc(arr, 10 * sizeof(int));\nprintf('%d', arr[8]);\n```", options: ["Unpredictable behavior", "0", "9", "Segmentation fault"], correct: 0 },
    
    // Files & Streams Section (Advanced)
    { question: "What happens when you try to write to a file opened in 'r' mode?", options: ["The file is created", "The file is overwritten", "The program crashes", "Nothing happens"], correct: 3 },
    { question: "What is the output of the following code?\n\n```c\nFILE *f = fopen('file.txt', 'w');\nfputs('Hello', f);\nfseek(f, 0, SEEK_SET);\nfputs('World', f);\nfclose(f);\n```", options: ["World", "Hello", "HelloWorld", "Error"], correct: 0 },
    { question: "What will happen if you attempt to read beyond the end of a file using 'fgets()'?", options: ["It will return NULL", "It will return the last read value", "It will cause an infinite loop", "None of the above"], correct: 0 },
    
    // Command-Line Arguments Section (Advanced)
    { question: "What will be the result of this code?\n\n```c\nint main(int argc, char *argv[]) {\n    printf('%s', argv[argc]);\n    return 0;\n}\n```", options: ["Undefined behavior", "The last command-line argument", "NULL", "Error"], correct: 0 },
    { question: "Which of the following is correct regarding 'argc' and 'argv'?", options: ["'argc' gives the number of arguments including the program name", "'argc' is always 0", "'argv' contains the number of command-line arguments", "None of the above"], correct: 0 },
    { question: "What does the following code output when run with `./program 1 2 3`?\n\n```c\nint main(int argc, char *argv[]) {\n    for (int i = 1; i < argc; i++) {\n        printf('%s ', argv[i]);\n    }\n    return 0;\n}\n```", options: ["1 2 3", "1 2", "2 3", "Error"], correct: 0 },

    // Challenging questions on Pointers, Dynamic Memory, and Structures
    { question: "What is the output of this code?\n\n```c\nint *p = malloc(sizeof(int));\n*p = 5;\nfree(p);\np = NULL;\nprintf('%d', *p);\n```", options: ["Error", "Segmentation fault", "5", "NULL"], correct: 1 },
    { question: "What will happen if you try to access memory that has been freed and is not NULL?", options: ["Segmentation fault", "The program will continue", "It will return the last allocated value", "None of the above"], correct: 0 },
    { question: "What will the following code print?\n\n```c\nstruct Point { int x, y; };\nstruct Point p = {1, 2};\nstruct Point *ptr = &p;\nprintf('%d %d', ptr->x, ptr->y);\n```", options: ["1 2", "2 1", "Segmentation fault", "None of the above"], correct: 0 },
    
    // More Advanced Dynamic Memory Questions
    { question: "What is the behavior of the following code?\n\n```c\nint *arr = malloc(5 * sizeof(int));\nfree(arr);\narr[0] = 10;\n```", options: ["Memory leak", "Segmentation fault", "Valid behavior", "None of the above"], correct: 1 },
    { question: "What happens when you use 'malloc' for an array of structures, and later access a member of that structure without initializing it?", options: ["It holds a garbage value", "It will be automatically initialized to zero", "It will result in undefined behavior", "None of the above"], correct: 0 },
    { question: "What happens when a dynamically allocated array is resized using 'realloc', and the new size is smaller than the original?", options: ["Data may be lost", "Memory is freed", "Array is cleared", "No effect"], correct: 0 },

    // Pointers and Dynamic Memory combined
    { question: "What is the result of this code?\n\n```c\nint *p = malloc(sizeof(int) * 3);\np[0] = 1; p[1] = 2; p[2] = 3;\nint *q = realloc(p, sizeof(int) * 2);\nprintf('%d', q[2]);\n```", options: ["Error", "3", "Undefined behavior", "Segmentation fault"], correct: 0 },
    
    // Challenging Command-Line Arguments questions
    { question: "What will the following code output if executed as `./program arg1 arg2`?\n\n```c\nint main(int argc, char *argv[]) {\n    printf('%s %s', argv[0], argv[argc - 1]);\n    return 0;\n}\n```", options: ["./program arg2", "arg1 arg2", "./program arg1", "Error"], correct: 0 },
    { question: "How do you access the first command-line argument (excluding the program name)?", options: ["argv[0]", "argv[1]", "argv[argc]", "None of the above"], correct: 1 },

    // Final Challenging Question on Pointers and Memory
    { question: "What happens when you attempt to dereference a pointer that was allocated memory via 'malloc', but was never initialized?", options: ["It may contain a random value", "It will be set to zero", "It will cause a segmentation fault", "None of the above"], correct: 0 },
];
</script>

        // Dynamically render questions
        const form = document.getElementById('examForm');

        questions.forEach((q, index) => {
            const div = document.createElement('div');
            div.classList.add('question');

            div.innerHTML = `
                <h3>${index + 1}. ${q.question}</h3>
                <ul class="options">
                    ${q.options.map((option, i) => `
                        <li>
                            <label>
                                <input type="radio" name="q${index + 1}" value="${i}">
                                ${option}
                            </label>
                        </li>
                    `).join('')}
                </ul>
                <button type="button" onclick="checkAnswer(${index})">Check Answer</button>
                <div class="feedback"></div>
            `;

            form.insertBefore(div, form.lastElementChild);
        });

        // Check individual answer
        function checkAnswer(index) {
            const selected = form.querySelector(`input[name="q${index + 1}"]:checked`);
            const feedbackDiv = form.querySelector(`.question:nth-child(${index + 1}) .feedback`);

            if (selected) {
                if (parseInt(selected.value) === questions[index].correct) {
                    feedbackDiv.textContent = "Correct!";
                    feedbackDiv.style.color = "green";
                } else {
                    feedbackDiv.textContent = "Incorrect. Try again!";
                    feedbackDiv.style.color = "red";
                }
            } else {
                feedbackDiv.textContent = "Please select an answer.";
                feedbackDiv.style.color = "orange";
            }
        }

        // Grade the exam
        function gradeExam() {
            let score = 0;
            const totalQuestions = questions.length;
            let unanswered = 0;

            questions.forEach((q, index) => {
                const selected = form.querySelector(`input[name="q${index + 1}"]:checked`);

                if (selected) {
                    if (parseInt(selected.value) === q.correct) {
                        score++;
                    }
                } else {
                    unanswered++;
                }
            });

            // Display results
            const resultDiv = document.getElementById('result');
            resultDiv.innerHTML = `You scored ${score} out of ${totalQuestions}.`;

            if (unanswered > 0) {
                resultDiv.innerHTML += ` You have ${unanswered} unanswered questions.`;
            }
        }
    </script>
</body>
</html>
